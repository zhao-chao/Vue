## 接口请求

- 之前一般请求方式只会用到 GET、POST，传参的时候一般是 http://www.baidu.com?name=xxx&age=18

- RESTFul API，请求方式更语义化（更具体了），传参方式变了 http://www.baidu.com/xxx/18

## 异步请求的问题

假如下一次的请求需要**依赖**上一次的返回结果，必须嵌套，层层嵌套下去，代码变得很难维护且不优雅，这种我们称为回调地狱

```js
// 后端代码
app.get('/data1', (req, res) => {
    res.send('data2')
});
app.get('/data2', (req, res) => {
    res.send('data3')
});
app.get('/data3', (req, res) => {
    res.send('Finish')
});
```

```js
// 前端代码
$.ajax({
    url: 'http://localhost:3000/data1',
    success: function (data) {
        // data => 'data2'
        $.ajax({
            url: `http://localhost:3000/${data}`,
            success: function (data) {
                // data => 'data3'
                $.ajax({
                    url: `http://localhost:3000/${data}`,
                    success: function (data) {
                        console.log(data)
                    }
                });
            }
        });
    }
});
```

## 解决方案

Promise（本质上是一个对象/方法），ES6 新出的用来解决回调地狱的一种编码方案

- 基本使用

```js
// 这里作为一个构造函数使用的，需要 new 一下
// 接收的参数是一个函数，函数里面又有两个参数
// 第 1 个参数是 resolve（解决），代表成功之后需要调用的方法
// 第 2 个参数是 reject（拒绝），代表失败之后需要调用的方法
const p = new Promise((resolve, reject) => {
    setTimeout(() => {
        if (Math.random() > 0.5) {
            // 这里可以传递成功之后的参数的
            resolve('成功');
        } else {
            // 这里可以传递失败之后的参数的
            reject('失败');
        }
    }, 1000);
});

// 要想拿到成功或失败之后的结果（就是resolve或者reject传递的参数），要通过 then
// then 里面也有两个参数，这两个参数都是函数，函数里面的参数就代表成功或失败的内容，说白了就是 resolve 或 reject 传递过来的参数
p.then(data => {
    // 成功就会走这里
    console.log(data);
}, err => {
    // 失败就会走这里
    console.log(err);
});
```

- 用 Promise 改造上面回调地狱的代码

Promise 确确实实可以解决回调地狱的问题，但是也确实不能简化代码，怎么又能解决回到地狱，又能简化代码呢？后面的 async/await

```js
function rq(path) {
    return new Promise((resolve, reject) => {
        $.ajax({
            url: `http://localhost:3000/${path}`,
            success: function (data) {
                // 成功之后，调用 resolve，把后端返回的真正的数据传递出去
                resolve(data);
            },
            error: function(err) {
                // 失败之后，就把错误对象传递出去
                reject(err);
            }
        });
    });
}
// 这个函数调用完后，拿到的结果就是 Promise 实例，是 Promise 就有 then 方法
rq('data1').then(data => {
    // 这个 data 就是成功之后拿到的结果呀
    // console.log(data);
    // rq(data) => 这个调用完后返回的也是 Promise 呀
    // 我又把这个 Promise 返回啦，返回之后可以继续通过 then 拿到这一次 resolve 的结果
    return rq(data);
    // 不要下面的写法，直接通过上面形式返回
    /*  rq(data).then(data => {
        rq(data).then(data => {
            console.log(data);
        })
    }) */
}).then(data => {
    return rq(data);
}).then(data => {
    console.log(data);
});
```